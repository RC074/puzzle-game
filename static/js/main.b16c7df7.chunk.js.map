{"version":3,"sources":["components/Board/Board.module.css","components/Records/Records.module.css","components/Functions/Functions.module.css","App.module.css","utils/Puzzle.ts","utils/Generator.ts","utils/Solver.ts","components/Board/Board.tsx","components/Records/Records.tsx","components/Functions/Functions.tsx","App.tsx","index.tsx"],"names":["module","exports","Puzzle","size","puzzle","pzSolved","findTile","tile","pz","y","x","generateChildNodes","prevMoves","childNodes","newNode","JSON","parse","stringify","push","manhattan","score","val","c_pos","f_pos","y_d","Math","abs","console","log","this","Generator","shuffle","arr","j","i","length","floor","random","make","potentialPz","sum","temp","Solver","AStar","queue","closeSet","shift","currentPz","gScore","step","nextChilds","sort","a","b","timeOut","ms","Promise","resolve","setTimeout","Board","board","swap","isPlaying","showPanel","finishedSolving","toggleInitialState","solvedByPlayer","useState","isClickable","setIsClickable","inSolvingProcess","setInSolvingProcess","tileStyle","setTileStyle","commandsLoader","useCallback","sequence","handleTileClick","useEffect","getStyle","n","styles","left","right","top","bottom","transition","col","row","player","isSwappable","tempTileStyle","col2","row2","swapTiles","className","styled","rows","tiles","style","onClick","Records","timeList","cookie","DisplayRecords","sortedTimeList","qSort","pivot","map","key","record","seconds","slice","formatTime","set","path","container","display","title","Functions","isSolving","restart","appendTime","timerInterval","setTimerInterval","timerTime","setTimerTime","btnVisibility","setBtnVisibility","menuWidth","setMenuWidth","clickable","setClickable","toggleVisibility","startTimer","clearInterval","toggleMenuWidth","interval","setInterval","width","timer","visibility","btn","App","state","isInitial","bodyColor","Cookies","togglePanel","appendToTimeList","time","setState","bool","new_pz","toggleSolvedByPlayer","toggleBodyColor","document","body","background","handleSwapTiles","tempBoard","handleSolve","handleFinishedSolving","undefined","get","start","id","name","type","onChange","htmlFor","React","Component","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.b16c7df7.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"board\":\"Board_board__25Olb\",\"rows\":\"Board_rows__17S8z\",\"tiles\":\"Board_tiles__1Oc-4\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Records_container__19mKB\",\"display\":\"Records_display__1nE_V\",\"title\":\"Records_title__jvqWA\",\"record\":\"Records_record__1VMuS\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Functions_container__3hbwH\",\"btn\":\"Functions_btn__12RTR\",\"timer\":\"Functions_timer__2ULnS\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"start\":\"App_start__Cd0ym\"};","// Puzzle.ts\r\n\r\nclass Puzzle {\r\n  // the number of tiles in the puzzle\r\n  size: 8;\r\n\r\n  // the 2d representation of the puzzle\r\n  puzzle: number[][];\r\n\r\n  // the solved version of the puzzle\r\n  pzSolved: number[][];\r\n\r\n  // takes in the size and the puzzle and populate them\r\n  constructor(size: 8, puzzle: number[][]) {\r\n    this.size = size;\r\n    this.puzzle = puzzle;\r\n    this.pzSolved = [\r\n      [1, 2, 3],\r\n      [4, 5, 6],\r\n      [7, 8, 0],\r\n    ];\r\n  }\r\n\r\n  // find the location of a tile and returns an array with size 2 of the coordinate\r\n  findTile = (tile: number, pz: number[][]) => {\r\n    for (let y = 0; y < this.size; y++) {\r\n      for (let x = 0; x < this.size; x++) {\r\n        if (pz[y][x] === tile) return [y, x];\r\n      }\r\n    }\r\n    // if not found, return below\r\n    return [-1, -1];\r\n  };\r\n\r\n  // the below method will generate the possible moves from a given state of a puzzle and returns\r\n  // an array of size 2, where the 1st item is the 2d representation of the new puzzle and\r\n  // the second item is the step required to generate that puzzle\r\n  // the step means how the blank tile will be swapped, so if the user wants the tile below the blank tile\r\n  // to swap with the blank tile, then the step will be u (for up)\r\n  generateChildNodes = (puzzle: number[][], prevMoves: string) => {\r\n    let childNodes = [];\r\n    let [y, x] = this.findTile(0, puzzle);\r\n    if (x > 0) {\r\n      // left\r\n      let newNode = JSON.parse(JSON.stringify(puzzle));\r\n      [newNode[y][x - 1], newNode[y][x]] = [newNode[y][x], newNode[y][x - 1]];\r\n      childNodes.push([newNode, prevMoves + \"l\"]);\r\n    }\r\n    if (x < 2) {\r\n      // right\r\n      let newNode = JSON.parse(JSON.stringify(puzzle));\r\n      [newNode[y][x + 1], newNode[y][x]] = [newNode[y][x], newNode[y][x + 1]];\r\n      childNodes.push([newNode, prevMoves + \"r\"]);\r\n    }\r\n    if (y > 0) {\r\n      // up\r\n      let newNode = JSON.parse(JSON.stringify(puzzle));\r\n      [newNode[y - 1][x], newNode[y][x]] = [newNode[y][x], newNode[y - 1][x]];\r\n      childNodes.push([newNode, prevMoves + \"u\"]);\r\n    }\r\n    if (y < 2) {\r\n      // down\r\n      let newNode = JSON.parse(JSON.stringify(puzzle));\r\n      [newNode[y + 1][x], newNode[y][x]] = [newNode[y][x], newNode[y + 1][x]];\r\n      childNodes.push([newNode, prevMoves + \"d\"]);\r\n    }\r\n    return childNodes;\r\n  };\r\n\r\n  // the manhattan distance of a tile is the sum of the absolute x and y distance from the current position of this tile to the location\r\n  // of this tile that it supposed to be in (the solved puzzle)\r\n\r\n  // for example\r\n  // 7 4 3\r\n  // 5   6\r\n  // 8 2 1\r\n  // the manhattan distance of the tile 4 is 2 because it is one up and one right from the place where it is suppose to go\r\n\r\n  // the below method sums up the manhattan distance for every tile and returns it as an integer\r\n  manhattan = (puzzle: number[][]) => {\r\n    let score = 0;\r\n    for (let val = 0; val <= this.size; val++) {\r\n      let c_pos = this.findTile(val, puzzle);\r\n      let f_pos = this.findTile(val, this.pzSolved);\r\n      if (!(c_pos === f_pos)) {\r\n        let y_d = Math.abs(c_pos[0] - f_pos[0]);\r\n        let x_d = Math.abs(c_pos[1] - f_pos[1]);\r\n        score += x_d + y_d;\r\n      }\r\n    }\r\n    console.log(score);\r\n    return score;\r\n  };\r\n}\r\n\r\nexport default Puzzle;\r\n","// Generator.ts\r\n\r\nimport Puzzle from \"./Puzzle\";\r\n\r\nclass Generator extends Puzzle {\r\n  // only taking in the size of the puzzle to generate, at this stage only 8\r\n  constructor(size: 8) {\r\n    super(size, [[]]);\r\n  }\r\n\r\n  // shuffle an array with number 0 to 8 and returns it\r\n  shuffle = (arr: number[]) => {\r\n    var j, x, i;\r\n    for (i = arr.length - 1; i > 0; i--) {\r\n      j = Math.floor(Math.random() * (i + 1));\r\n      x = arr[i];\r\n      arr[i] = arr[j];\r\n      arr[j] = x;\r\n    }\r\n    return arr;\r\n  };\r\n\r\n  // The make method will keep generate random puzzles until it is checked to be solvable\r\n  make = () => {\r\n    while (true) {\r\n      let potentialPz = this.shuffle([1, 2, 3, 4, 5, 6, 7, 8, 0]);\r\n\r\n      // checks solvability by counting the number of inversions\r\n      // a inversion is counted for any number i, where there is another number j, when index of j and the value of j is both greater than i\r\n      // example: (0 represents empty tile and doesn't count for anything)\r\n\r\n      // ? [1, 8, 2, 0, 4, 3, 7, 6, 5] inversions: 10\r\n      // ? [8, 1, 2, 0, 4, 3, 7, 6, 5] inversions: 11\r\n\r\n      // * IF the inversion is an odd number, then the puzzle will not be solvable\r\n\r\n      // the below code basically checks the inversions for each number in the puzzle and add them up\r\n      let sum = 0;\r\n      for (let i = 0; i < 8; i++) {\r\n        if (potentialPz[i] === 0) continue;\r\n        for (let j = i + 1; j < 9; j++) {\r\n          if (potentialPz[j] === 0) continue;\r\n          if (potentialPz[i] > potentialPz[j]) {\r\n            sum++;\r\n          }\r\n        }\r\n      }\r\n      // reference: https://www.geeksforgeeks.org/check-instance-8-puzzle-solvable/\r\n      // the below code will check whether if the puzzle is solvable based on the inversion variable called sum\r\n      // then the below code will format the array to a 2d array\r\n      if (sum % 2 === 0) {\r\n        let pz: number[][] = [];\r\n        for (let i = 0; i < 9; i += 3) {\r\n          let temp = [];\r\n          for (let j = i; j < i + 3; j++) {\r\n            temp.push(potentialPz[j]);\r\n          }\r\n          pz.push(temp);\r\n        }\r\n        return pz;\r\n      }\r\n      continue;\r\n    }\r\n  };\r\n}\r\n\r\nexport default Generator;\r\n","// Solver.ts\r\n\r\nimport Puzzle from \"./Puzzle\";\r\n\r\nclass Solver extends Puzzle {\r\n  // A* (pronounced \"A-star\") is a graph traversal and path search algorithm\r\n  // the below algorithm will solve the puzzle and returns a string of steps to solve the puzzle\r\n  AStar = () => {\r\n    // essentially the steps, or the count, doesn't matter that much, but useful in testing phase\r\n    let gScore: number = 0;\r\n\r\n    // the queue that store a list of possible steps of the puzzle\r\n    let queue: any = [[this.puzzle, gScore, this.manhattan(this.puzzle), \"\"]];\r\n\r\n    // the below hash table saves all the steps to prevent the algorithm going in circle\r\n    interface Dict {\r\n      [key: string]: boolean;\r\n    }\r\n    let closeSet: Dict = {};\r\n\r\n    // keep generating child nodes of the current puzzle and turn the node with the least manhattan distance to be\r\n    // the current puzzle and then repeat until the puzzle is solved\r\n    while (queue.length !== 0) {\r\n      // eslint-disable-next-line\r\n\r\n      // these four variables below hold the information of the current puzzle\r\n      // currentPz: 2d array representation of the puzzle\r\n      // gScore: depth\r\n      // hScore: the manhattan distance\r\n      // step: either l, r, u, d: left right up or down, which is the move that leads to this state of the puzzle\r\n      let [currentPz, gScore, hScore, step] = queue.shift();\r\n      closeSet[JSON.stringify(currentPz)] = true;\r\n\r\n      // utilize the helper function to generate all the possible instances of the puzzles after swapping the current puzzle (possible outcomes)\r\n      let nextChilds = this.generateChildNodes(currentPz, step);\r\n\r\n      // checks every outcome, if the outcome is not the solved puzzle, push it to the queue\r\n      for (let i = 0; i < nextChilds.length; i++) {\r\n        if (\r\n          JSON.stringify(nextChilds[i][0]) === JSON.stringify(this.pzSolved)\r\n        ) {\r\n          return nextChilds[i][1];\r\n        } else if (closeSet[JSON.stringify(nextChilds[i][0])] !== true) {\r\n          queue.push([\r\n            nextChilds[i][0],\r\n\r\n            gScore + 1,\r\n\r\n            this.manhattan(nextChilds[i][0]),\r\n\r\n            nextChilds[i][1],\r\n          ]);\r\n        }\r\n      }\r\n      // sort the queue so that the instance with the last manhattan distance will be evaluated next\r\n      // keep in mind, the less the manhattan distance, the closer it is to the solved version\r\n      queue.sort((a: number[], b: number[]) => a[2] - b[2]);\r\n    }\r\n  };\r\n}\r\n\r\nexport default Solver;\r\n","// Board.tsx\r\n\r\n// React library tools\r\nimport React, { useState, useEffect, useCallback } from \"react\";\r\n\r\n// Puzzle class and A star solver class\r\nimport Solver from \"../../utils/Solver\";\r\nimport Puzzle from \"../../utils/Puzzle\";\r\n\r\n// css styling\r\nimport styled from \"./Board.module.css\";\r\n\r\n// specifying the attributes and methods that will be passed as props to the Board component\r\ntype BoardProps = {\r\n  board: number[][];\r\n  swap: (col: number, row: number, col2: number, row2: number) => void;\r\n  isPlaying: boolean;\r\n  showPanel: (bool: boolean) => void;\r\n  finishedSolving: () => void;\r\n  toggleInitialState: (bool: boolean) => void;\r\n  solvedByPlayer: (bool: boolean) => void;\r\n};\r\n\r\n// used for sleep/wait, takes in a number as millisecond and sleep for that long\r\nconst timeOut = (ms: number) => {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n};\r\n\r\n// the below is the board component, which will be displayed to screen as the game board on the web app and as well a container\r\n// for any attributes and methods that is related to the board\r\nconst Board: React.FC<BoardProps> = ({\r\n  board,\r\n  swap,\r\n  isPlaying,\r\n  showPanel,\r\n  finishedSolving,\r\n  toggleInitialState,\r\n  solvedByPlayer,\r\n}) => {\r\n  // below are some variables that help certain methods to decide whether to perform a certain action or not\r\n  const [isClickable, setIsClickable] = useState(true);\r\n  const [inSolvingProcess, setInSolvingProcess] = useState(false);\r\n  const [tileStyle, setTileStyle] = useState([0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\n\r\n  // from the proposal, we know that the a star algorithm will return a string of moves that can take the board from the current state to its complete form\r\n  // the below method takes in that string and utilize other methods to actually move the tiles on board and solves it visually\r\n  const commandsLoader = useCallback(\r\n    async (sequence: string) => {\r\n      for (let i = 0; i < sequence.length; i++) {\r\n        let [y, x] = findTile(0);\r\n        if (sequence[i] === \"u\") y--;\r\n        if (sequence[i] === \"d\") y++;\r\n        if (sequence[i] === \"r\") x++;\r\n        if (sequence[i] === \"l\") x--;\r\n        handleTileClick(y, x, false);\r\n        await timeOut(500);\r\n      }\r\n      finishedSolving();\r\n      setInSolvingProcess(false);\r\n    },\r\n    [board]\r\n  );\r\n\r\n  // useEffect is a react library tool\r\n  // in short,\r\n  useEffect(() => {\r\n    if (isPlaying && !inSolvingProcess) {\r\n      let pz = new Solver(8, board);\r\n      commandsLoader(pz.AStar());\r\n      setInSolvingProcess(true);\r\n      showPanel(false);\r\n    }\r\n  }, [isPlaying, inSolvingProcess, showPanel, commandsLoader, board]);\r\n\r\n  // this method will call the handleSwapTiles method in the parent component (App.tsx)\r\n  const swapTiles = (col: number, row: number, col2: number, row2: number) => {\r\n    swap(col, row, col2, row2);\r\n  };\r\n\r\n  // make a temporary instance of the Puzzle class, then use the findTile method to get the coords of the tile\r\n  const findTile = (tile: number) => {\r\n    let tempBoard = new Puzzle(8, board);\r\n    return tempBoard.findTile(tile, board);\r\n  };\r\n\r\n  // check if the given tile at the coordinate provided is swappable\r\n  const isSwappable = (col: number, row: number) => {\r\n    let [y, x] = findTile(0);\r\n    if (y === col && Math.abs(x - row) === 1) return true;\r\n    if (x === row && Math.abs(y - col) === 1) return true;\r\n    return false;\r\n  };\r\n\r\n  // Return the css style that will be applied to one of the tile\r\n  const getStyle = (n: number) => {\r\n    interface Dict {\r\n      [key: string]: string;\r\n    }\r\n    let styles: Dict = {};\r\n    if (tileStyle[n] === 0) {\r\n      styles = { left: \"0vw\", right: \"0vw\", top: \"0vw\", bottom: \"0vw\" };\r\n    }\r\n    if (tileStyle[n] === 3) {\r\n      styles = { bottom: \"9.3vw\", transition: \"bottom 0.5s\" };\r\n    }\r\n    if (tileStyle[n] === 4) {\r\n      styles = { top: \"9.3vw\", transition: \"top 0.5s\" };\r\n    }\r\n    if (tileStyle[n] === 2) {\r\n      styles = { right: \"9.3vw\", transition: \"right 0.5s\" };\r\n    }\r\n    if (tileStyle[n] === 1) {\r\n      styles = { left: \"9.3vw\", transition: \"left 0.5s\" };\r\n    }\r\n    if (n === 0) {\r\n      styles[\"background\"] = \"transparent\";\r\n    }\r\n    return styles;\r\n  };\r\n\r\n  // this method will swap a tile with the blank tile\r\n  // the coordinate of the tile are the col and row in the parameter, the boolean player indicates whether or not it is a player who swapped the tile\r\n  // because this method is also used by the a star solver\r\n\r\n  const handleTileClick = (col: number, row: number, player: boolean) => {\r\n    // if this tiles are not meant to be clicked at the time, quit the method\r\n    if (!isClickable) return;\r\n\r\n    // check if they are swappable, where the tile clicked is actually beside the blank tile\r\n    if (isSwappable(col, row)) {\r\n      let [y, x] = findTile(0);\r\n      let tempTileStyle = [...tileStyle];\r\n\r\n      // set the corresponding code so that the style can be changed for the visual swapping effects\r\n      if (y === col && x > row) {\r\n        tempTileStyle[0] = 2;\r\n        tempTileStyle[board[col][row]] = 1;\r\n      }\r\n      if (y === col && x < row) {\r\n        tempTileStyle[0] = 1;\r\n        tempTileStyle[board[col][row]] = 2;\r\n      }\r\n      if (x === row && y > col) {\r\n        tempTileStyle[0] = 3;\r\n        tempTileStyle[board[col][row]] = 4;\r\n      }\r\n      if (x === row && y < col) {\r\n        tempTileStyle[0] = 4;\r\n        tempTileStyle[board[col][row]] = 3;\r\n      }\r\n\r\n      // change the style of the tiles\r\n      setTileStyle([...tempTileStyle]);\r\n\r\n      // during the swapping animation, stop user from clicking\r\n      setIsClickable(false);\r\n\r\n      // since the animation of the swap is 0.5s, therefore the below code will execute after 0.5s to clean up everything\r\n      // which actually change the 2d array of the board and reset all styles of the tiles\r\n      setTimeout(() => {\r\n        setTileStyle([0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\n        swapTiles(col, row, y, x);\r\n        if (\r\n          JSON.stringify(board) ===\r\n          JSON.stringify([\r\n            [1, 2, 3],\r\n            [4, 5, 6],\r\n            [7, 8, 0],\r\n          ])\r\n        ) {\r\n          if (player) solvedByPlayer(true);\r\n          toggleInitialState(false);\r\n        }\r\n        setIsClickable(true);\r\n      }, 500);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={styled.board}>\r\n      <ul className={styled.rows}>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[0][0])}\r\n          onClick={() => handleTileClick(0, 0, true)}\r\n        >\r\n          {board[0][0] === 0 ? \"\" : board[0][0]}\r\n        </li>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[0][1])}\r\n          onClick={() => handleTileClick(0, 1, true)}\r\n        >\r\n          {board[0][1] === 0 ? \"\" : board[0][1]}\r\n        </li>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[0][2])}\r\n          onClick={() => handleTileClick(0, 2, true)}\r\n        >\r\n          {board[0][2] === 0 ? \"\" : board[0][2]}\r\n        </li>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[1][0])}\r\n          onClick={() => handleTileClick(1, 0, true)}\r\n        >\r\n          {board[1][0] === 0 ? \"\" : board[1][0]}\r\n        </li>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[1][1])}\r\n          onClick={() => handleTileClick(1, 1, true)}\r\n        >\r\n          {board[1][1] === 0 ? \"\" : board[1][1]}\r\n        </li>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[1][2])}\r\n          onClick={() => handleTileClick(1, 2, true)}\r\n        >\r\n          {board[1][2] === 0 ? \"\" : board[1][2]}\r\n        </li>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[2][0])}\r\n          onClick={() => handleTileClick(2, 0, true)}\r\n        >\r\n          {board[2][0] === 0 ? \"\" : board[2][0]}\r\n        </li>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[2][1])}\r\n          onClick={() => handleTileClick(2, 1, true)}\r\n        >\r\n          {board[2][1] === 0 ? \"\" : board[2][1]}\r\n        </li>\r\n        <li\r\n          className={styled.tiles}\r\n          style={getStyle(board[2][2])}\r\n          onClick={() => handleTileClick(2, 2, true)}\r\n        >\r\n          {board[2][2] === 0 ? \"\" : board[2][2]}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Board;\r\n","// Records.tsx\r\n\r\nimport React from \"react\";\r\nimport Cookies from \"universal-cookie/es6\";\r\nimport styled from \"./Records.module.css\";\r\n\r\ninterface RecordsProps {\r\n  timeList: number[];\r\n  cookie: Cookies;\r\n}\r\n\r\n// using the definition and steps for quicksort\r\nconst qSort = (arr: number[]): number[] => {\r\n  // if empty or only one item, just return it, base case\r\n  if (arr.length <= 1) return arr;\r\n\r\n  // always select the last element as the pivot\r\n  const pivot = arr[arr.length - 1];\r\n\r\n  // will later be populated into the left and right array of the pivot\r\n  const left = [];\r\n  const right = [];\r\n\r\n  // go through the arr, any number smaller than pivot will be added to the left, if bigger then added to right\r\n\r\n  for (let i = 0; i < arr.length - 1; i++) {\r\n    if (arr[i] < pivot) {\r\n      left.push(arr[i]);\r\n    } else {\r\n      right.push(arr[i]);\r\n    }\r\n  }\r\n\r\n  // recursive call\r\n  return [...qSort(left), pivot, ...qSort(right)];\r\n};\r\n\r\n// format ms to minutes : seconds\r\nconst formatTime = (ms: number) => {\r\n  let seconds = (\"0\" + (Math.floor(ms / 1000) % 60)).slice(-2);\r\n  let minutes = (\"0\" + (Math.floor(ms / 60000) % 60)).slice(-2);\r\n  return minutes + \":\" + seconds;\r\n};\r\n\r\n// Time records component\r\nconst Records: React.FC<RecordsProps> = ({ timeList, cookie }) => {\r\n  // sort and display the time records in timeList, the return is the timeList in html so that it can be rendered\r\n  const DisplayRecords = () => {\r\n    timeList = qSort(timeList);\r\n    const sortedTimeList = timeList.map((val, i) => (\r\n      <div key={i} className={styled.record}>\r\n        {formatTime(val)}\r\n      </div>\r\n    ));\r\n    // save the time records to the cookie\r\n    if (timeList.length > 0) {\r\n      cookie.set(\"timeList\", JSON.stringify(timeList), { path: \"/\" });\r\n    }\r\n    return <div>{sortedTimeList}</div>;\r\n  };\r\n\r\n  return (\r\n    <div className={styled.container}>\r\n      <div className={styled.display}>\r\n        <div className={styled.title}>Records</div>\r\n        <DisplayRecords />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Records;\r\n","// Functions.tsx\r\n\r\nimport React, { useState, useEffect } from \"react\";\r\nimport styled from \"./Functions.module.css\";\r\n\r\ninterface FunctionsProps {\r\n  showPanel: boolean;\r\n  isSolving: () => void;\r\n  restart: () => void;\r\n  appendTime: (time: number) => void;\r\n}\r\n\r\n// another instance of the sleep function, i have two copies of this function because it's more complicated\r\n// to import things around, this is a function with one line so I will put one in each file that needs one\r\nconst timeOut = (ms: number) => {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n};\r\n\r\n// Function component (the little panel on the right of the board that pops up)\r\nconst Functions: React.FC<FunctionsProps> = ({\r\n  showPanel,\r\n  isSolving,\r\n  restart,\r\n  appendTime,\r\n}) => {\r\n  // necessary variables to keep track of things, such as the visibility of the panel and etc...\r\n  const [timerInterval, setTimerInterval] = useState<any>();\r\n  const [timerTime, setTimerTime] = useState(0);\r\n  const [btnVisibility, setBtnVisibility] = useState(false);\r\n  const [menuWidth, setMenuWidth] = useState(false);\r\n  const [clickable, setClickable] = useState(true);\r\n\r\n  // this whole block of code below basically setup the panel, whenever the showPanel variable changes, it runs\r\n  // at the very beginning, you will not see the panel because it's not during the puzzle solving\r\n  // the panel will only be activated when the play is solving the puzzle\r\n  useEffect(() => {\r\n    const toggleVisibility = async () => {\r\n      setClickable(false);\r\n      if (showPanel === true) {\r\n        startTimer();\r\n        await timeOut(300);\r\n      } else {\r\n        appendTime(timerTime);\r\n        setTimerTime(0);\r\n        clearInterval(timerInterval);\r\n      }\r\n      setBtnVisibility(showPanel ? true : false);\r\n      setClickable(true);\r\n    };\r\n    const toggleMenuWidth = async () => {\r\n      setClickable(false);\r\n      setMenuWidth(showPanel ? true : false);\r\n      setClickable(true);\r\n    };\r\n    if (clickable) {\r\n      toggleVisibility();\r\n      toggleMenuWidth();\r\n    }\r\n  }, [showPanel]);\r\n\r\n  // the counter in the panel that shows the increment of time\r\n  const startTimer = () => {\r\n    const interval = setInterval(() => {\r\n      setTimerTime((timerTime) => timerTime + 1000);\r\n    }, 1000);\r\n    setTimerInterval(interval);\r\n  };\r\n\r\n  // this method was used by the startTimer method above\r\n  // the below method formats the time into 00:00\r\n  const timer = () => {\r\n    if (timerTime === 3599000) {\r\n      clearInterval(timerInterval);\r\n    }\r\n    let seconds = (\"0\" + (Math.floor(timerTime / 1000) % 60)).slice(-2);\r\n    let minutes = (\"0\" + (Math.floor(timerTime / 60000) % 60)).slice(-2);\r\n    return minutes + \":\" + seconds;\r\n  };\r\n\r\n  // if the user click the solve button, pass this command to app.tsx and let it deal with it\r\n  const handleSolve = () => {\r\n    isSolving();\r\n  };\r\n\r\n  // if the user click the restart button, pass this command to app.tsx and let it deal with it\r\n  const handleRestart = () => {\r\n    restart();\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={styled.container}\r\n      style={{ width: menuWidth ? \"12vw\" : \"0\" }}\r\n    >\r\n      <div\r\n        className={styled.timer}\r\n        style={{ visibility: btnVisibility ? \"visible\" : \"hidden\" }}\r\n      >\r\n        {timer()}\r\n      </div>\r\n      <button\r\n        className={styled.btn}\r\n        onClick={handleSolve}\r\n        style={{ visibility: btnVisibility ? \"visible\" : \"hidden\" }}\r\n      >\r\n        Solve\r\n      </button>\r\n      <button\r\n        className={styled.btn}\r\n        onClick={handleRestart}\r\n        style={{ visibility: btnVisibility ? \"visible\" : \"hidden\" }}\r\n      >\r\n        Restart\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Functions;\r\n","// App.tsx\n// This is where the components like Board, Functions, Records communicate with each other\n\nimport React from \"react\";\n\n// Puzzle class child\nimport Generator from \"./utils/Generator\";\n\n// Components\nimport Board from \"./components/Board/Board\";\nimport Records from \"./components/Records/Records\";\nimport Functions from \"./components/Functions/Functions\";\n\n// Cookie library to save cookies\nimport Cookies from \"universal-cookie/es6\";\n\n// css styling\nimport \"./body.css\";\nimport \"./toggle.css\";\nimport styled from \"./App.module.css\";\n\n// The attributes that the App component will contain\ninterface AppState {\n  board: number[][];\n  isPlaying: boolean;\n  isInitial: boolean;\n  showPanel: boolean;\n  bodyColor: boolean;\n  solvedByPlayer: boolean;\n  timeList: number[];\n}\n\n// A sleep method\nconst timeOut = (ms: number) => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n\n// App component\nclass App extends React.Component<{}, AppState> {\n  // the Attributes with their initial values\n  state = {\n    board: [\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 0],\n    ],\n    isPlaying: false,\n    isInitial: true,\n    showPanel: false,\n    bodyColor: false,\n    timeList: [],\n    cookie: new Cookies(),\n    solvedByPlayer: false,\n  };\n\n  // Run only once, after the component is rendered to the screen\n  // Retrieve the cookie if there is any, and display them to the user\n  componentDidMount() {\n    if (this.state.cookie.get(\"timeList\") !== undefined) {\n      this.setState({ timeList: this.state.cookie.get(\"timeList\") });\n    }\n  }\n\n  // the restart bubble click\n  restart = async () => {\n    this.togglePanel(false);\n    await timeOut(500);\n    this.toggleInitialState(false);\n  };\n\n  // The method that adds a new record to the timeList\n  appendToTimeList = (time: number) => {\n    if (this.state.solvedByPlayer) {\n      let temp: number[] = [...this.state.timeList];\n      temp.push(time);\n      this.setState({ timeList: temp });\n      this.setState({ solvedByPlayer: false });\n    }\n  };\n\n  // This method is what the restart button uses to restart the game\n  // the below code will reset the game and generate a new puzzle\n  toggleInitialState = (bool: boolean) => {\n    if (bool) {\n      let new_pz = new Generator(8).make();\n      this.setState({ board: new_pz });\n    }\n    this.setState({ isInitial: !this.state.isInitial });\n    this.togglePanel(bool);\n  };\n\n  // Toggles the visibility of the panel on the right of the board\n  // where the panel consists of solve, restart buttons...\n  togglePanel = (bool: boolean) => {\n    this.setState({ showPanel: bool });\n  };\n\n  // This method will change the attribute \"solvedByPlayer\" in the state to the given boolean\n  toggleSolvedByPlayer = (bool: boolean) => {\n    this.setState({ solvedByPlayer: bool });\n  };\n\n  // this method essentially toggles dark mode on/off\n  toggleBodyColor = () => {\n    this.setState({ bodyColor: !this.state.bodyColor });\n    document.body.style.background = this.state.bodyColor\n      ? \"#cacdd4\"\n      : \"#27282a\";\n  };\n\n  // To swap the tiles in the 2d array representation NOT VISUALLY\n  handleSwapTiles = (col: number, row: number, col2: number, row2: number) => {\n    let tempBoard = this.state.board;\n    [tempBoard[col][row], tempBoard[col2][row2]] = [\n      tempBoard[col2][row2],\n      tempBoard[col][row],\n    ];\n    this.setState({ board: tempBoard });\n  };\n\n  // Switching the attribute \"isPlaying\" to true, this with activate the a star in the board component\n  handleSolve = () => {\n    this.setState({ isPlaying: true });\n  };\n\n  // Similar to above, but stopping the a star\n  handleFinishedSolving = () => {\n    this.setState({ isPlaying: false });\n  };\n\n  render() {\n    return (\n      <div>\n        <div>\n          {this.state.isInitial ? (\n            <button\n              className={styled.start}\n              onClick={() => this.toggleInitialState(true)}\n            >\n              START\n            </button>\n          ) : (\n            \"\"\n          )}\n          <Records timeList={this.state.timeList} cookie={this.state.cookie} />\n          <Functions\n            showPanel={this.state.showPanel}\n            isSolving={this.handleSolve}\n            restart={this.restart}\n            appendTime={(time) => this.appendToTimeList(time)}\n          />\n          <Board\n            board={this.state.board}\n            swap={(col, row, col2, row2) =>\n              this.handleSwapTiles(col, row, col2, row2)\n            }\n            isPlaying={this.state.isPlaying}\n            showPanel={(bool) => this.togglePanel(bool)}\n            toggleInitialState={(bool) => this.toggleInitialState(bool)}\n            finishedSolving={this.handleFinishedSolving}\n            solvedByPlayer={(bool) => this.toggleSolvedByPlayer(bool)}\n          />\n        </div>\n        <div className=\"toggle-wrapper\">\n          <input\n            id=\"provideMuffins\"\n            name=\"provideMuffins\"\n            className=\"toggle\"\n            type=\"checkbox\"\n            onChange={this.toggleBodyColor}\n          />\n          <label htmlFor=\"provideMuffins\" className=\"toggle--label\"></label>\n          <div className=\"foux-toggle\"></div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// index.tsx\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}